"use strict";(globalThis.webpackChunkgodot_iap_docs=globalThis.webpackChunkgodot_iap_docs||[]).push([[868],{5159(e,n,r){r.d(n,{A:()=>i});r(6540);var s=r(6025),t=r(7856),a=r(4848);function i({title:e}){const n=(0,s.Ay)("/img/iapkit-banner.gif"),r=()=>{fetch(t.I,{method:"POST"}).catch(()=>{})};return(0,a.jsxs)("div",{style:{flex:1,marginTop:24,marginBottom:24},children:[(0,a.jsx)("a",{href:t.V,target:"_blank",rel:"noopener noreferrer",onClick:r,children:(0,a.jsx)("img",{src:n,alt:"IAPKit - In-App Purchase Solution",style:{display:"block",margin:"0 auto",objectFit:"contain"}})}),e?(0,a.jsx)("a",{href:t.V,target:"_blank",rel:"noopener noreferrer",onClick:r,style:{display:"block",fontSize:"0.875rem",color:"#666",textAlign:"center",marginTop:"8px",textDecoration:"none"},children:e}):null]})}},5554(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"examples/available-purchases","title":"Available Purchases","description":"This example demonstrates how to implement purchase restoration for non-consumable products and subscriptions.","source":"@site/docs/examples/available-purchases.md","sourceDirName":"examples","slug":"/examples/available-purchases","permalink":"/godot-iap/examples/available-purchases","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/godot-iap/tree/main/docs/docs/examples/available-purchases.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Available Purchases","sidebar_label":"Available Purchases","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Subscription Flow","permalink":"/godot-iap/examples/subscription-flow"},"next":{"title":"AI Assistants","permalink":"/godot-iap/guides/ai-assistants"}}');var t=r(4848),a=r(8453),i=r(5159);const o={title:"Available Purchases",sidebar_label:"Available Purchases",sidebar_position:3},c="Available Purchases (Restore) Example",l={},u=[{value:"Overview",id:"overview",level:2},{value:"Complete Implementation",id:"complete-implementation",level:2},{value:"RestorePurchases.gd",id:"restorepurchasesgd",level:3},{value:"RestoreUI.gd",id:"restoreuigd",level:3},{value:"Auto-Restore on Startup",id:"auto-restore-on-startup",level:2},{value:"Platform-Specific Behavior",id:"platform-specific-behavior",level:2},{value:"iOS Behavior",id:"ios-behavior",level:3},{value:"Android Behavior",id:"android-behavior",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"available-purchases-restore-example",children:"Available Purchases (Restore) Example"})}),"\n",(0,t.jsx)(i.A,{}),"\n",(0,t.jsx)(n.p,{children:"This example demonstrates how to implement purchase restoration for non-consumable products and subscriptions."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Purchase restoration allows users to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Recover purchased content when reinstalling the app"}),"\n",(0,t.jsx)(n.li,{children:"Sync purchases across multiple devices"}),"\n",(0,t.jsx)(n.li,{children:"Restore access after clearing app data"}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"Apple Requirement",type:"info",children:(0,t.jsx)(n.p,{children:'Apple requires all apps with non-consumable purchases or subscriptions to include a "Restore Purchases" button.'})}),"\n",(0,t.jsx)(n.h2,{id:"complete-implementation",children:"Complete Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"restorepurchasesgd",children:"RestorePurchases.gd"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'# restore_purchases.gd\nextends Node\n\nvar iap: GodotIap = null\n\nsignal restore_completed(purchases: Array)\nsignal restore_failed(error: String)\nsignal restore_progress(current: int, total: int)\n\nfunc _ready():\n    if Engine.has_singleton("GodotIap"):\n        iap = Engine.get_singleton("GodotIap")\n\nfunc restore_all_purchases() -> Array:\n    """Restore all non-consumable purchases and subscriptions"""\n    if not iap:\n        restore_failed.emit("IAP not available")\n        return []\n\n    print("Starting purchase restoration...")\n\n    # Get all available purchases\n    var purchases_json = iap.get_available_purchases()\n    var purchases = JSON.parse_string(purchases_json)\n\n    if purchases.size() == 0:\n        print("No purchases to restore")\n        restore_completed.emit([])\n        return []\n\n    print("Found %d purchases to restore" % purchases.size())\n\n    var restored_purchases: Array = []\n    var total = purchases.size()\n\n    for i in range(total):\n        var purchase = purchases[i]\n        restore_progress.emit(i + 1, total)\n\n        # Process each purchase\n        var result = await _process_restore(purchase)\n        if result:\n            restored_purchases.append(purchase)\n\n    print("Restored %d purchases" % restored_purchases.size())\n    restore_completed.emit(restored_purchases)\n\n    return restored_purchases\n\nfunc _process_restore(purchase: Dictionary) -> bool:\n    var product_id = purchase.productId\n    print("Processing: ", product_id)\n\n    # Check if already processed\n    if _is_already_granted(product_id):\n        print("  Already granted, skipping")\n        return true\n\n    # Verify purchase validity\n    var is_valid = await _verify_purchase(purchase)\n    if not is_valid:\n        print("  Verification failed")\n        return false\n\n    # Check if subscription is still active\n    if _is_subscription(product_id):\n        if not _is_subscription_active(purchase):\n            print("  Subscription expired")\n            return false\n\n    # Grant the content\n    _grant_purchase(product_id)\n    print("  Restored successfully")\n\n    return true\n\nfunc _verify_purchase(purchase: Dictionary) -> bool:\n    """Verify purchase on your server"""\n    # For development\n    if OS.is_debug_build():\n        return true\n\n    # Production: Implement server verification\n    # var response = await your_server.verify(purchase)\n    # return response.is_valid\n\n    return true\n\nfunc _is_already_granted(product_id: String) -> bool:\n    """Check if content is already granted"""\n    match product_id:\n        "com.yourgame.remove_ads":\n            return GameState.ads_removed\n        "com.yourgame.premium", "com.yourgame.premium_monthly", "com.yourgame.premium_yearly":\n            return GameState.is_premium\n        _:\n            return false\n\nfunc _is_subscription(product_id: String) -> bool:\n    var subscription_ids = [\n        "com.yourgame.premium_monthly",\n        "com.yourgame.premium_yearly"\n    ]\n    return product_id in subscription_ids\n\nfunc _is_subscription_active(purchase: Dictionary) -> bool:\n    var current_time = Time.get_unix_time_from_system() * 1000\n\n    if OS.get_name() == "iOS":\n        var expiration = purchase.get("expirationDateIOS", 0)\n        if expiration > 0:\n            return expiration > current_time\n\n        # Sandbox testing\n        if purchase.get("environmentIOS") == "Sandbox":\n            var day_ms = 24 * 60 * 60 * 1000\n            var tx_date = purchase.get("transactionDate", 0)\n            return (current_time - tx_date) < day_ms\n\n    elif OS.get_name() == "Android":\n        var auto_renewing = purchase.get("autoRenewingAndroid", null)\n        if auto_renewing != null:\n            return auto_renewing\n\n        if purchase.get("purchaseState") == "purchased":\n            return true\n\n    return false\n\nfunc _grant_purchase(product_id: String):\n    match product_id:\n        "com.yourgame.remove_ads":\n            GameState.set_ads_removed(true)\n\n        "com.yourgame.premium", "com.yourgame.premium_monthly", "com.yourgame.premium_yearly":\n            GameState.set_premium(true)\n\n        _:\n            print("Unknown product: ", product_id)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"restoreuigd",children:"RestoreUI.gd"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'# restore_ui.gd\nextends Control\n\n@onready var restore_button: Button = $RestoreButton\n@onready var progress_label: Label = $ProgressLabel\n@onready var status_label: Label = $StatusLabel\n\nvar restore_manager: Node\n\nfunc _ready():\n    restore_manager = RestorePurchases.new()\n    add_child(restore_manager)\n\n    # Connect signals\n    restore_manager.restore_completed.connect(_on_restore_completed)\n    restore_manager.restore_failed.connect(_on_restore_failed)\n    restore_manager.restore_progress.connect(_on_restore_progress)\n\n    # Connect button\n    restore_button.pressed.connect(_on_restore_pressed)\n\n    # Initial state\n    progress_label.hide()\n\nfunc _on_restore_pressed():\n    restore_button.disabled = true\n    progress_label.show()\n    status_label.text = "Restoring purchases..."\n\n    await restore_manager.restore_all_purchases()\n\nfunc _on_restore_progress(current: int, total: int):\n    progress_label.text = "Processing %d of %d..." % [current, total]\n\nfunc _on_restore_completed(purchases: Array):\n    restore_button.disabled = false\n    progress_label.hide()\n\n    if purchases.size() > 0:\n        status_label.text = "Restored %d purchases!" % purchases.size()\n        _show_restored_items(purchases)\n    else:\n        status_label.text = "No purchases found to restore."\n        _show_dialog("No Purchases", "No previous purchases were found for this account.")\n\nfunc _on_restore_failed(error: String):\n    restore_button.disabled = false\n    progress_label.hide()\n    status_label.text = "Restore failed"\n\n    _show_dialog("Error", "Failed to restore purchases: " + error)\n\nfunc _show_restored_items(purchases: Array):\n    var items = []\n    for purchase in purchases:\n        items.append("\u2022 " + _get_product_name(purchase.productId))\n\n    var message = "Successfully restored:\\n\\n" + "\\n".join(items)\n    _show_dialog("Purchases Restored", message)\n\nfunc _get_product_name(product_id: String) -> String:\n    match product_id:\n        "com.yourgame.remove_ads":\n            return "Remove Ads"\n        "com.yourgame.premium":\n            return "Premium Upgrade"\n        "com.yourgame.premium_monthly":\n            return "Premium Monthly"\n        "com.yourgame.premium_yearly":\n            return "Premium Yearly"\n        _:\n            return product_id\n\nfunc _show_dialog(title: String, message: String):\n    var dialog = AcceptDialog.new()\n    dialog.title = title\n    dialog.dialog_text = message\n    add_child(dialog)\n    dialog.popup_centered()\n    dialog.confirmed.connect(dialog.queue_free)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"auto-restore-on-startup",children:"Auto-Restore on Startup"}),"\n",(0,t.jsx)(n.p,{children:"Automatically check for purchases when the app starts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'# main.gd or autoload\nextends Node\n\nfunc _ready():\n    # Wait for IAP to initialize\n    if IapManager.is_connected:\n        _check_purchases_on_startup()\n    else:\n        IapManager.connection_changed.connect(_on_iap_connected)\n\nfunc _on_iap_connected(connected: bool):\n    if connected:\n        _check_purchases_on_startup()\n\nfunc _check_purchases_on_startup():\n    print("Checking for existing purchases...")\n\n    var iap = Engine.get_singleton("GodotIap")\n    var purchases = JSON.parse_string(iap.get_available_purchases())\n\n    for purchase in purchases:\n        # Only process non-consumables and active subscriptions\n        if _should_restore(purchase):\n            _restore_silently(purchase)\n\nfunc _should_restore(purchase: Dictionary) -> bool:\n    var product_id = purchase.productId\n\n    # Skip consumables\n    if _is_consumable(product_id):\n        return false\n\n    # Check subscriptions\n    if _is_subscription(product_id):\n        return _is_subscription_active(purchase)\n\n    return true\n\nfunc _restore_silently(purchase: Dictionary):\n    # Grant without showing UI\n    var product_id = purchase.productId\n\n    match product_id:\n        "com.yourgame.remove_ads":\n            if not GameState.ads_removed:\n                GameState.set_ads_removed(true)\n                print("Silently restored: Remove Ads")\n\n        "com.yourgame.premium_monthly", "com.yourgame.premium_yearly":\n            if not GameState.is_premium:\n                GameState.set_premium(true)\n                print("Silently restored: Premium")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"platform-specific-behavior",children:"Platform-Specific Behavior"}),"\n",(0,t.jsx)(n.h3,{id:"ios-behavior",children:"iOS Behavior"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func restore_ios():\n    # iOS returns all non-consumable purchases ever made\n    # Filter by what\'s still valid\n\n    var purchases = JSON.parse_string(iap.get_available_purchases())\n\n    for purchase in purchases:\n        # Check subscription expiration\n        if _is_subscription(purchase.productId):\n            var expiration = purchase.get("expirationDateIOS", 0)\n            var now = Time.get_unix_time_from_system() * 1000\n\n            if expiration > 0 and expiration < now:\n                print("Subscription expired: ", purchase.productId)\n                continue\n\n        # Verify and grant\n        _grant_purchase(purchase.productId)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"android-behavior",children:"Android Behavior"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func restore_android():\n    # Android queries both in-app and subscription purchases\n    # Already filtered by purchase state\n\n    var purchases = JSON.parse_string(iap.get_available_purchases())\n\n    for purchase in purchases:\n        var state = purchase.get("purchaseState", "")\n\n        if state != "purchased":\n            continue\n\n        # Check if acknowledged (unacknowledged = pending completion)\n        var acknowledged = purchase.get("isAcknowledgedAndroid", false)\n\n        if not acknowledged:\n            # This purchase wasn\'t properly finished before\n            print("Found unfinished purchase: ", purchase.productId)\n            # Process and finish it\n            await _complete_pending_purchase(purchase)\n        else:\n            # Already acknowledged, just restore\n            _grant_purchase(purchase.productId)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func restore_with_error_handling():\n    var iap = Engine.get_singleton("GodotIap")\n\n    if not iap:\n        _show_error("Store not available. Please try again later.")\n        return\n\n    # Check connection first\n    var result = JSON.parse_string(iap.init_connection())\n    if not result.get("success", false):\n        _show_error("Cannot connect to store. Please check your internet connection.")\n        return\n\n    # Get purchases\n    var purchases_json = iap.get_available_purchases()\n    var purchases = JSON.parse_string(purchases_json)\n\n    if typeof(purchases) != TYPE_ARRAY:\n        _show_error("Failed to retrieve purchases.")\n        return\n\n    if purchases.size() == 0:\n        _show_info("No purchases found for this account.")\n        return\n\n    # Process purchases\n    var restored = 0\n    var failed = 0\n\n    for purchase in purchases:\n        var success = await _try_restore(purchase)\n        if success:\n            restored += 1\n        else:\n            failed += 1\n\n    # Show result\n    if failed > 0:\n        _show_warning("Restored %d purchases. %d failed to restore." % [restored, failed])\n    elif restored > 0:\n        _show_success("Successfully restored %d purchases!" % restored)\n    else:\n        _show_info("No new purchases to restore.")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Always include restore button"}),": Required by Apple for apps with non-consumables"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Auto-restore on startup"}),": Check for purchases silently when app starts"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Verify purchases"}),": Always verify on your server in production"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Handle subscriptions correctly"}),": Check expiration dates"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Show progress"}),": For multiple purchases, show restoration progress"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Handle errors gracefully"}),": Network issues, invalid purchases, etc."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./purchase-flow",children:"Purchase Flow Example"})," - Basic purchase implementation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./subscription-flow",children:"Subscription Flow Example"})," - Subscription handling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../guides/purchases",children:"Purchases Guide"})," - Detailed documentation"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},7856(e,n,r){r.d(n,{I:()=>t,V:()=>s});const s="https://iapkit.com",t="https://www.hyo.dev/api/ad-banner/cmju2uzzm0000yr9h3dhpflgy"},8453(e,n,r){r.d(n,{R:()=>i,x:()=>o});var s=r(6540);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);