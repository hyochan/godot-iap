"use strict";(globalThis.webpackChunkgodot_iap_docs=globalThis.webpackChunkgodot_iap_docs||[]).push([[946],{1437(e,n,t){t.d(n,{A:()=>o});t(6540);var r=t(7856),s=t(4848);function o({children:e,path:n=""}){return(0,s.jsx)("a",{href:`${r.V}${n}`,target:"_blank",rel:"noopener noreferrer",onClick:()=>{navigator.sendBeacon?navigator.sendBeacon(r.I):fetch(r.I,{method:"POST",keepalive:!0}).catch(()=>{})},children:e})}},5159(e,n,t){t.d(n,{A:()=>i});t(6540);var r=t(6025),s=t(7856),o=t(4848);function i({title:e}){const n=(0,r.Ay)("/img/iapkit-banner.gif"),t=()=>{fetch(s.I,{method:"POST"}).catch(()=>{})};return(0,o.jsxs)("div",{style:{flex:1,marginTop:24,marginBottom:24},children:[(0,o.jsx)("a",{href:s.V,target:"_blank",rel:"noopener noreferrer",onClick:t,children:(0,o.jsx)("img",{src:n,alt:"IAPKit - In-App Purchase Solution",style:{display:"block",margin:"0 auto",objectFit:"contain"}})}),e?(0,o.jsx)("a",{href:s.V,target:"_blank",rel:"noopener noreferrer",onClick:t,style:{display:"block",fontSize:"0.875rem",color:"#666",textAlign:"center",marginTop:"8px",textDecoration:"none"},children:e}):null]})}},7856(e,n,t){t.d(n,{I:()=>s,V:()=>r});const r="https://iapkit.com",s="https://www.hyo.dev/api/ad-banner/cmju2uzzm0000yr9h3dhpflgy"},8453(e,n,t){t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}},8949(e,n,t){t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>d,default:()=>_,frontMatter:()=>c,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"examples/purchase-flow","title":"Purchase Flow","description":"This example demonstrates a complete in-app purchase implementation for a Godot game using the type-safe API.","source":"@site/docs/examples/purchase-flow.md","sourceDirName":"examples","slug":"/examples/purchase-flow","permalink":"/godot-iap/examples/purchase-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/godot-iap/tree/main/docs/docs/examples/purchase-flow.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Purchase Flow","sidebar_label":"Purchase Flow","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Android-Specific Methods","permalink":"/godot-iap/api/methods/android-specific"},"next":{"title":"Subscription Flow","permalink":"/godot-iap/examples/subscription-flow"}}');var s=t(4848),o=t(8453),i=t(5159),a=t(1437);const c={title:"Purchase Flow",sidebar_label:"Purchase Flow",sidebar_position:1},d="Purchase Flow Example",p={},u=[{value:"Overview",id:"overview",level:2},{value:"Complete Implementation",id:"complete-implementation",level:2},{value:"IapManager.gd (Autoload)",id:"iapmanagergd-autoload",level:3},{value:"StoreUI.gd (Store Interface)",id:"storeuigd-store-interface",level:3},{value:"ProductButton.gd",id:"productbuttongd",level:3},{value:"GameState.gd (Autoload)",id:"gamestategd-autoload",level:3},{value:"Type System",id:"type-system",level:2},{value:"Platform-Specific Types (Sealed Class Pattern)",id:"platform-specific-types-sealed-class-pattern",level:3},{value:"Testing",id:"testing",level:2},{value:"iOS Testing",id:"ios-testing",level:3},{value:"Android Testing",id:"android-testing",level:3},{value:"Server-Side Verification",id:"server-side-verification",level:2},{value:"See Also",id:"see-also",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"purchase-flow-example",children:"Purchase Flow Example"})}),"\n",(0,s.jsx)(i.A,{}),"\n",(0,s.jsxs)(n.p,{children:["This example demonstrates a complete in-app purchase implementation for a Godot game using the ",(0,s.jsx)(n.strong,{children:"type-safe API"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"This example shows how to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Initialize the IAP connection"}),"\n",(0,s.jsx)(n.li,{children:"Fetch and display products with typed objects"}),"\n",(0,s.jsx)(n.li,{children:"Handle purchases with proper verification"}),"\n",(0,s.jsx)(n.li,{children:"Finish transactions correctly"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"complete-implementation",children:"Complete Implementation"}),"\n",(0,s.jsx)(n.h3,{id:"iapmanagergd-autoload",children:"IapManager.gd (Autoload)"}),"\n",(0,s.jsx)(n.p,{children:"Create this script and add it as an Autoload singleton in Project Settings."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'# iap_manager.gd\nextends Node\n\n# Load OpenIAP types for type-safe API\nconst Types = preload("res://addons/godot-iap/types.gd")\n\n# GodotIapWrapper reference\nvar iap: Node\n\n# Connection state\nvar is_connected: bool = false\n\n# Product data - stored as typed objects\nvar products: Dictionary = {}  # product_id -> Types.ProductAndroid or Types.ProductIOS\n\n# Product IDs\nconst PRODUCT_IDS = {\n    "coins_100": "com.yourgame.coins_100",\n    "coins_500": "com.yourgame.coins_500",\n    "remove_ads": "com.yourgame.remove_ads",\n    "premium_monthly": "com.yourgame.premium_monthly"\n}\n\n# Signals for other scripts to connect to\nsignal connection_changed(connected: bool)\nsignal products_loaded(products: Array)\nsignal purchase_completed(product_id: String)\nsignal purchase_failed(error: Dictionary)\n\nfunc _ready():\n    _setup_iap_node()\n    _initialize_iap()\n\nfunc _setup_iap_node():\n    # Create GodotIapWrapper node dynamically for Autoload\n    var wrapper = preload("res://addons/godot-iap/godot_iap.gd").new()\n    wrapper.name = "GodotIapWrapper"\n    add_child(wrapper)\n    iap = wrapper\n\nfunc _initialize_iap():\n    # Connect signals\n    iap.purchase_updated.connect(_on_purchase_updated)\n    iap.purchase_error.connect(_on_purchase_error)\n    iap.products_fetched.connect(_on_products_fetched)\n\n    # Initialize connection - returns bool\n    is_connected = iap.init_connection()\n\n    if is_connected:\n        print("IAP connected successfully")\n        connection_changed.emit(true)\n        _check_pending_purchases()\n        _load_products()\n    else:\n        print("IAP connection failed")\n        connection_changed.emit(false)\n\nfunc _check_pending_purchases():\n    # Returns Array of typed purchase objects\n    var purchases = iap.get_available_purchases()\n    for purchase in purchases:\n        await _process_purchase(purchase)\n\nfunc _load_products():\n    # Create typed ProductRequest\n    var request = Types.ProductRequest.new()\n    request.skus = PRODUCT_IDS.values()\n    request.type = Types.ProductQueryType.ALL\n\n    # Returns Array of typed product objects\n    var fetched_products = iap.fetch_products(request)\n    _process_products(fetched_products)\n\nfunc _process_products(fetched_products: Array):\n    for product in fetched_products:\n        # Access typed properties directly\n        products[product.id] = product\n        print("Loaded: %s - %s" % [product.id, product.display_price])\n    products_loaded.emit(fetched_products)\n\n# Signal handlers\nfunc _on_products_fetched(result: Dictionary):\n    # iOS async callback\n    if result.has("products"):\n        for product_dict in result["products"]:\n            var id = product_dict.get("id", "")\n            products[id] = product_dict\n        products_loaded.emit(products.values())\n\nfunc _on_purchase_updated(purchase: Dictionary):\n    await _process_purchase_dict(purchase)\n\nfunc _on_purchase_error(error: Dictionary):\n    var code = error.get("code", "")\n\n    if code == "USER_CANCELED":\n        print("User cancelled purchase")\n    else:\n        print("Purchase error: ", error.get("message", ""))\n        purchase_failed.emit(error)\n\nfunc _process_purchase(purchase) -> void:\n    # Works with both typed objects and dictionaries\n    var product_id = purchase.product_id if purchase is Object else purchase.get("productId", "")\n    var state = purchase.purchase_state if purchase is Object else purchase.get("purchaseState", "")\n\n    print("Processing purchase: %s (state: %s)" % [product_id, state])\n\n    if state == "Pending" or state == "pending":\n        print("Purchase pending approval")\n        return\n\n    if state != "Purchased" and state != "purchased":\n        return\n\n    # Verify purchase on server (recommended for production)\n    var is_valid = await _verify_purchase(purchase)\n    if not is_valid:\n        print("Purchase verification failed")\n        return\n\n    # Grant the content\n    _grant_purchase(product_id)\n\n    # Finish the transaction with typed input\n    var is_consumable = _is_consumable(product_id)\n    var purchase_input: Types.PurchaseInput\n    if purchase is Object:\n        purchase_input = Types.PurchaseInput.new()\n        purchase_input.product_id = purchase.product_id\n        purchase_input.purchase_token = purchase.purchase_token if "purchase_token" in purchase else ""\n        purchase_input.transaction_id = purchase.transaction_id if "transaction_id" in purchase else ""\n    else:\n        purchase_input = Types.PurchaseInput.from_dict(purchase)\n\n    var result = iap.finish_transaction(purchase_input, is_consumable)\n    if result.success:\n        print("Transaction finished for: ", product_id)\n        purchase_completed.emit(product_id)\n\nfunc _process_purchase_dict(purchase: Dictionary) -> void:\n    await _process_purchase(purchase)\n\n# Public API\nfunc buy_product(product_id: String):\n    if not is_connected:\n        push_error("IAP not connected")\n        return\n\n    # Create typed RequestPurchaseProps\n    var props = Types.RequestPurchaseProps.new()\n    props.request = Types.RequestPurchasePropsByPlatforms.new()\n\n    # Android configuration\n    props.request.google = Types.RequestPurchaseAndroidProps.new()\n    props.request.google.skus = [product_id]\n\n    # iOS configuration\n    props.request.apple = Types.RequestPurchaseIosProps.new()\n    props.request.apple.sku = product_id\n\n    props.type = Types.ProductQueryType.IN_APP\n\n    # Returns typed purchase object or null\n    var purchase = iap.request_purchase(props)\n    if purchase:\n        print("Purchase initiated: ", purchase.product_id)\n\nfunc restore_purchases():\n    if not is_connected:\n        push_error("IAP not connected")\n        return\n\n    # Returns typed VoidResult\n    var result = iap.restore_purchases()\n    if result.success:\n        print("Restore initiated")\n\nfunc get_product(product_id: String):\n    return products.get(product_id, null)\n\nfunc get_product_price(product_id: String) -> String:\n    var product = get_product(product_id)\n    if product == null:\n        return "$0.99"\n    # Access typed property\n    return product.display_price if product.display_price else "$0.99"\n\n# Helper functions\nfunc _is_consumable(product_id: String) -> bool:\n    return product_id in [PRODUCT_IDS.coins_100, PRODUCT_IDS.coins_500]\n\nfunc _verify_purchase(purchase) -> bool:\n    # For development, return true\n    # For production, use IAPKit for server-side verification\n    if OS.is_debug_build():\n        return true\n\n    # Production: Verify with IAPKit\n    return await _verify_with_iapkit(purchase)\n\nfunc _verify_with_iapkit(purchase) -> bool:\n    var http = HTTPRequest.new()\n    add_child(http)\n\n    var headers = [\n        "Content-Type: application/json",\n        "Authorization: Bearer YOUR_IAPKIT_API_KEY"  # Get from iapkit.com\n    ]\n\n    var purchase_token = ""\n    if purchase is Object:\n        purchase_token = purchase.purchase_token if "purchase_token" in purchase else ""\n    else:\n        purchase_token = purchase.get("purchaseToken", "")\n\n    var body = {}\n    if OS.get_name() == "iOS":\n        body = { "apple": { "jws": purchase_token } }\n    elif OS.get_name() == "Android":\n        body = { "google": { "purchaseToken": purchase_token } }\n\n    http.request(\n        "https://api.iapkit.com/v1/verify",\n        headers,\n        HTTPClient.METHOD_POST,\n        JSON.stringify(body)\n    )\n\n    var response = await http.request_completed\n    http.queue_free()\n\n    if response[1] != 200:\n        return false\n\n    var result = JSON.parse_string(response[3].get_string_from_utf8())\n    if result is Dictionary:\n        var state = result.get("state", "")\n        return state == "entitled" or state == "ready-to-consume"\n\n    return false\n\nfunc _grant_purchase(product_id: String):\n    match product_id:\n        PRODUCT_IDS.coins_100:\n            GameState.add_coins(100)\n            print("Granted 100 coins")\n\n        PRODUCT_IDS.coins_500:\n            GameState.add_coins(500)\n            print("Granted 500 coins")\n\n        PRODUCT_IDS.remove_ads:\n            GameState.set_ads_removed(true)\n            print("Ads removed")\n\n        PRODUCT_IDS.premium_monthly:\n            GameState.set_premium(true)\n            print("Premium activated")\n\n        _:\n            print("Unknown product: ", product_id)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"storeuigd-store-interface",children:"StoreUI.gd (Store Interface)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'# store_ui.gd\nextends Control\n\nconst Types = preload("res://addons/godot-iap/types.gd")\n\n@onready var product_container: VBoxContainer = $ProductContainer\n@onready var loading_label: Label = $LoadingLabel\n@onready var restore_button: Button = $RestoreButton\n\n# Product button scene (create this in the editor)\nvar product_button_scene = preload("res://ui/product_button.tscn")\n\nfunc _ready():\n    # Connect to IapManager signals\n    IapManager.connection_changed.connect(_on_connection_changed)\n    IapManager.products_loaded.connect(_on_products_loaded)\n    IapManager.purchase_completed.connect(_on_purchase_completed)\n    IapManager.purchase_failed.connect(_on_purchase_failed)\n\n    restore_button.pressed.connect(_on_restore_pressed)\n\n    # Check if already connected\n    if IapManager.is_connected:\n        loading_label.text = "Loading products..."\n    else:\n        loading_label.text = "Connecting to store..."\n\nfunc _on_connection_changed(connected: bool):\n    if connected:\n        loading_label.text = "Loading products..."\n    else:\n        loading_label.text = "Store unavailable"\n\nfunc _on_products_loaded(products: Array):\n    loading_label.hide()\n    _display_products(products)\n\nfunc _display_products(products: Array):\n    # Clear existing buttons\n    for child in product_container.get_children():\n        child.queue_free()\n\n    # Create button for each product\n    for product in products:\n        var button = product_button_scene.instantiate()\n        # Access typed properties directly\n        button.setup(product.id, product.title, product.display_price)\n        button.pressed.connect(func(): _on_product_pressed(product.id))\n        product_container.add_child(button)\n\nfunc _on_product_pressed(product_id: String):\n    print("Purchasing: ", product_id)\n    set_buttons_enabled(false)\n    IapManager.buy_product(product_id)\n\nfunc _on_purchase_completed(product_id: String):\n    set_buttons_enabled(true)\n    show_success_dialog("Purchase successful!")\n\nfunc _on_purchase_failed(error: Dictionary):\n    set_buttons_enabled(true)\n    var code = error.get("code", "")\n    if code != "USER_CANCELED":\n        show_error_dialog(error.get("message", "Purchase failed"))\n\nfunc _on_restore_pressed():\n    set_buttons_enabled(false)\n    IapManager.restore_purchases()\n    # Results come through purchase_updated signal\n    await get_tree().create_timer(2.0).timeout\n    set_buttons_enabled(true)\n\nfunc set_buttons_enabled(enabled: bool):\n    for child in product_container.get_children():\n        if child is Button:\n            child.disabled = not enabled\n    restore_button.disabled = not enabled\n\nfunc show_success_dialog(message: String):\n    var dialog = AcceptDialog.new()\n    dialog.title = "Success"\n    dialog.dialog_text = message\n    add_child(dialog)\n    dialog.popup_centered()\n    dialog.confirmed.connect(dialog.queue_free)\n\nfunc show_error_dialog(message: String):\n    var dialog = AcceptDialog.new()\n    dialog.title = "Error"\n    dialog.dialog_text = message\n    add_child(dialog)\n    dialog.popup_centered()\n    dialog.confirmed.connect(dialog.queue_free)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"productbuttongd",children:"ProductButton.gd"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'# product_button.gd\nextends Button\n\n@onready var title_label: Label = $TitleLabel\n@onready var price_label: Label = $PriceLabel\n\nvar product_id: String = ""\n\nfunc setup(id: String, title: String, price: String):\n    product_id = id\n    title_label.text = title\n    price_label.text = price\n'})}),"\n",(0,s.jsx)(n.h3,{id:"gamestategd-autoload",children:"GameState.gd (Autoload)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'# game_state.gd\nextends Node\n\nvar coins: int = 0\nvar ads_removed: bool = false\nvar is_premium: bool = false\n\nconst SAVE_PATH = "user://game_state.save"\n\nfunc _ready():\n    load_state()\n\nfunc add_coins(amount: int):\n    coins += amount\n    save_state()\n\nfunc remove_coins(amount: int) -> bool:\n    if coins >= amount:\n        coins -= amount\n        save_state()\n        return true\n    return false\n\nfunc set_ads_removed(value: bool):\n    ads_removed = value\n    save_state()\n\nfunc set_premium(value: bool):\n    is_premium = value\n    save_state()\n\nfunc save_state():\n    var file = FileAccess.open(SAVE_PATH, FileAccess.WRITE)\n    if file:\n        var data = {\n            "coins": coins,\n            "ads_removed": ads_removed,\n            "is_premium": is_premium\n        }\n        file.store_string(JSON.stringify(data))\n        file.close()\n\nfunc load_state():\n    if FileAccess.file_exists(SAVE_PATH):\n        var file = FileAccess.open(SAVE_PATH, FileAccess.READ)\n        if file:\n            var data = JSON.parse_string(file.get_as_text())\n            if data:\n                coins = data.get("coins", 0)\n                ads_removed = data.get("ads_removed", false)\n                is_premium = data.get("is_premium", false)\n            file.close()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"type-system",children:"Type System"}),"\n",(0,s.jsx)(n.h3,{id:"platform-specific-types-sealed-class-pattern",children:"Platform-Specific Types (Sealed Class Pattern)"}),"\n",(0,s.jsxs)(n.p,{children:["GDScript doesn't support Union types like Dart's ",(0,s.jsx)(n.code,{children:"sealed class"}),". Functions that return platform-specific types use:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Return Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"-> Array"})}),(0,s.jsxs)(n.td,{children:["Array of ",(0,s.jsx)(n.code,{children:"Types.ProductAndroid"})," OR ",(0,s.jsx)(n.code,{children:"Types.ProductIOS"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"-> Variant"})}),(0,s.jsxs)(n.td,{children:["Typed object OR ",(0,s.jsx)(n.code,{children:"null"})]})]})]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'# fetch_products returns Array of typed products\nvar products = iap.fetch_products(request)\nfor product in products:\n    # On Android: product is Types.ProductAndroid\n    # On iOS: product is Types.ProductIOS\n    # Both have common properties: id, title, display_price\n    print(product.id, " - ", product.display_price)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,s.jsx)(n.h3,{id:"ios-testing",children:"iOS Testing"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create sandbox test accounts in App Store Connect"}),"\n",(0,s.jsx)(n.li,{children:"Sign out of App Store on device"}),"\n",(0,s.jsx)(n.li,{children:"Launch game and make a purchase"}),"\n",(0,s.jsx)(n.li,{children:"Sign in with sandbox account when prompted"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"android-testing",children:"Android Testing"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Upload signed APK to Google Play Console (internal testing)"}),"\n",(0,s.jsx)(n.li,{children:"Add your test account to license testers"}),"\n",(0,s.jsx)(n.li,{children:"Install the app from Play Store"}),"\n",(0,s.jsx)(n.li,{children:"Test purchases (won't be charged)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"server-side-verification",children:"Server-Side Verification"}),"\n",(0,s.jsxs)(n.p,{children:["For production apps, we recommend using ",(0,s.jsx)(a.A,{children:"IAPKit"})," for server-side purchase verification. The example above includes ",(0,s.jsx)(n.code,{children:"_verify_with_iapkit()"})," which calls IAPKit's verification API."]}),"\n",(0,s.jsxs)(n.p,{children:["Get your API key at ",(0,s.jsx)(a.A,{children:"iapkit.com"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./subscription-flow",children:"Subscription Flow Example"})," - Subscription implementation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./available-purchases",children:"Available Purchases Example"})," - Purchase restoration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../guides/purchases",children:"Purchases Guide"})," - Detailed purchase documentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(a.A,{children:"IAPKit Dashboard"})," - Server-side verification service"]}),"\n"]})]})}function _(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);