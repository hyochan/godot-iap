"use strict";(globalThis.webpackChunkgodot_iap_docs=globalThis.webpackChunkgodot_iap_docs||[]).push([[839],{1437(e,n,s){s.d(n,{A:()=>i});s(6540);var r=s(7856),t=s(4848);function i({children:e,path:n=""}){return(0,t.jsx)("a",{href:`${r.V}${n}`,target:"_blank",rel:"noopener noreferrer",onClick:()=>{navigator.sendBeacon?navigator.sendBeacon(r.I):fetch(r.I,{method:"POST",keepalive:!0}).catch(()=>{})},children:e})}},5159(e,n,s){s.d(n,{A:()=>a});s(6540);var r=s(6025),t=s(7856),i=s(4848);function a({title:e}){const n=(0,r.Ay)("/img/iapkit-banner.gif"),s=()=>{fetch(t.I,{method:"POST"}).catch(()=>{})};return(0,i.jsxs)("div",{style:{flex:1,marginTop:24,marginBottom:24},children:[(0,i.jsx)("a",{href:t.V,target:"_blank",rel:"noopener noreferrer",onClick:s,children:(0,i.jsx)("img",{src:n,alt:"IAPKit - In-App Purchase Solution",style:{display:"block",margin:"0 auto",objectFit:"contain"}})}),e?(0,i.jsx)("a",{href:t.V,target:"_blank",rel:"noopener noreferrer",onClick:s,style:{display:"block",fontSize:"0.875rem",color:"#666",textAlign:"center",marginTop:"8px",textDecoration:"none"},children:e}):null]})}},6503(e,n,s){s.r(n),s.d(n,{assets:()=>p,contentTitle:()=>c,default:()=>l,frontMatter:()=>o,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"guides/purchases","title":"Purchases","description":"This guide covers the complete purchase flow for in-app purchases in Godot using the type-safe API.","source":"@site/docs/guides/purchases.md","sourceDirName":"guides","slug":"/guides/purchases","permalink":"/godot-iap/guides/purchases","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/godot-iap/tree/main/docs/docs/guides/purchases.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Purchases","sidebar_label":"Purchases","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Lifecycle","permalink":"/godot-iap/guides/lifecycle"},"next":{"title":"Subscription Offers","permalink":"/godot-iap/guides/subscription-offers"}}');var t=s(4848),i=s(8453),a=s(5159);s(1437);const o={title:"Purchases",sidebar_label:"Purchases",sidebar_position:2},c="Purchases",p={},u=[{value:"Purchase Flow Overview",id:"purchase-flow-overview",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Basic Purchase Flow",id:"basic-purchase-flow",level:2},{value:"1. Setup Purchase Signals",id:"1-setup-purchase-signals",level:3},{value:"2. Handle Purchase Updates",id:"2-handle-purchase-updates",level:3},{value:"3. Handle Purchase Errors",id:"3-handle-purchase-errors",level:3},{value:"4. Request a Purchase",id:"4-request-a-purchase",level:3},{value:"Platform Differences",id:"platform-differences",level:2},{value:"iOS",id:"ios",level:3},{value:"Android",id:"android",level:3},{value:"Product Types",id:"product-types",level:2},{value:"Consumable Products",id:"consumable-products",level:3},{value:"Non-Consumable Products",id:"non-consumable-products",level:3},{value:"Subscriptions",id:"subscriptions",level:3},{value:"Getting Product Information",id:"getting-product-information",level:2},{value:"Display Products",id:"display-products",level:3},{value:"Purchase Restoration",id:"purchase-restoration",level:2},{value:"Purchase Verification",id:"purchase-verification",level:2},{value:"Server-Side Verification",id:"server-side-verification",level:3},{value:"Using Native Verification",id:"using-native-verification",level:3},{value:"Handling Pending Purchases",id:"handling-pending-purchases",level:2},{value:"Subscription Status",id:"subscription-status",level:2},{value:"Checking Subscription Status",id:"checking-subscription-status",level:3},{value:"Managing Subscriptions",id:"managing-subscriptions",level:3},{value:"Handling Unfinished Transactions",id:"handling-unfinished-transactions",level:2},{value:"Complete Example",id:"complete-example",level:2},{value:"Testing Purchases",id:"testing-purchases",level:2},{value:"iOS Testing",id:"ios-testing",level:3},{value:"Android Testing",id:"android-testing",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"purchases",children:"Purchases"})}),"\n",(0,t.jsx)(a.A,{}),"\n",(0,t.jsxs)(n.p,{children:["This guide covers the complete purchase flow for in-app purchases in Godot using the ",(0,t.jsx)(n.strong,{children:"type-safe API"}),"."]}),"\n",(0,t.jsxs)(n.admonition,{title:"Purchase Flow Design",type:"warning",children:[(0,t.jsxs)(n.p,{children:["The purchase flow uses an ",(0,t.jsx)(n.strong,{children:"event pattern"})," rather than a callback pattern:"]}),(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Multiple responses may occur when requesting a payment"}),"\n",(0,t.jsxs)(n.li,{children:["Purchases are inter-session ",(0,t.jsx)(n.strong,{children:"asynchronous"})," - requests may complete after the app is closed"]}),"\n",(0,t.jsx)(n.li,{children:"Purchases may be pending and hard to track"}),"\n",(0,t.jsx)(n.li,{children:"Always use signals to handle purchase results"}),"\n"]})]}),"\n",(0,t.jsxs)(n.p,{children:["For a comprehensive understanding of the purchase lifecycle, see our ",(0,t.jsx)(n.a,{href:"./lifecycle",children:"Lifecycle Guide"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"purchase-flow-overview",children:"Purchase Flow Overview"}),"\n",(0,t.jsxs)(n.p,{children:["Once you have called ",(0,t.jsx)(n.code,{children:"fetch_products()"})," and have a valid response, you can call ",(0,t.jsx)(n.code,{children:"request_purchase()"}),". Subscribable products can be purchased just like consumable products."]}),"\n",(0,t.jsx)(n.p,{children:"Before you request any purchase, you should connect to the purchase signals. It is recommended to start listening to updates as soon as your application launches."}),"\n",(0,t.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Event-driven"}),": Purchases are handled through signals rather than return values"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Asynchronous"}),": Purchases may complete after your app is closed or crashed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation required"}),": Always validate purchases on your server"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Finish transactions"}),": Always finish transactions after processing"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"basic-purchase-flow",children:"Basic Purchase Flow"}),"\n",(0,t.jsx)(n.h3,{id:"1-setup-purchase-signals",children:"1. Setup Purchase Signals"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'extends Node\n\nconst Types = preload("res://addons/godot-iap/types.gd")\n\n@onready var iap = $GodotIapWrapper\n\nvar products: Array = []\n\nfunc _ready():\n    _setup_signals()\n    _initialize()\n\nfunc _setup_signals():\n    # Core purchase signals\n    iap.purchase_updated.connect(_on_purchase_updated)\n    iap.purchase_error.connect(_on_purchase_error)\n    iap.products_fetched.connect(_on_products_fetched)\n    iap.connected.connect(_on_connected)\n\nfunc _initialize():\n    if iap.init_connection():\n        _load_products()\n\nfunc _load_products():\n    var request = Types.ProductRequest.new()\n    var skus: Array[String] = ["coins_100", "coins_500", "remove_ads"]\n    request.skus = skus\n    request.type = Types.ProductQueryType.ALL\n\n    # Returns Array of Types.ProductAndroid or Types.ProductIOS\n    products = iap.fetch_products(request)\n    for product in products:\n        print("Product: ", product.id, " - ", product.display_price)\n\nfunc _on_connected():\n    print("Store connected")\n\nfunc _on_products_fetched(result: Dictionary):\n    # Handle async products fetch (iOS)\n    if result.has("products"):\n        for product_dict in result["products"]:\n            print("Fetched: ", product_dict.get("id", ""))\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-handle-purchase-updates",children:"2. Handle Purchase Updates"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func _on_purchase_updated(purchase: Dictionary):\n    var state = purchase.get("purchaseState", "")\n    var product_id = purchase.get("productId", "")\n\n    print("Purchase updated: ", product_id, " state: ", state)\n\n    match state:\n        "purchased", "Purchased":\n            # Validate on server first\n            var is_valid = await validate_on_server(purchase)\n\n            if is_valid:\n                # Grant the content\n                grant_purchase(product_id)\n\n                # Finish the transaction\n                _finish_transaction(purchase)\n            else:\n                print("Purchase validation failed")\n\n        "pending", "Pending":\n            # Payment is pending (e.g., parental approval)\n            print("Purchase pending: ", product_id)\n            show_pending_message()\n\n        _:\n            print("Unknown purchase state: ", state)\n\nfunc _finish_transaction(purchase: Dictionary):\n    var is_consumable = is_consumable_product(purchase.get("productId", ""))\n    var result = iap.finish_transaction_dict(purchase, is_consumable)\n    if result.success:\n        print("Transaction finished")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-handle-purchase-errors",children:"3. Handle Purchase Errors"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func _on_purchase_error(error: Dictionary):\n    var code = error.get("code", "")\n    var message = error.get("message", "")\n\n    match code:\n        "USER_CANCELED":\n            # User cancelled - no action needed\n            print("Purchase cancelled by user")\n\n        "NETWORK_ERROR":\n            show_error("Network error. Please check your connection.")\n\n        "ITEM_UNAVAILABLE":\n            show_error("This product is currently unavailable.")\n\n        "ITEM_ALREADY_OWNED":\n            # User already owns this product - restore it\n            show_error("You already own this product.")\n            restore_purchases()\n\n        "PAYMENT_INVALID":\n            show_error("Payment was invalid. Please try again.")\n\n        "PAYMENT_NOT_ALLOWED":\n            show_error("Payments are not allowed on this device.")\n\n        _:\n            show_error("Purchase failed: " + message)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"4-request-a-purchase",children:"4. Request a Purchase"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func buy_product(product_id: String):\n    var props = Types.RequestPurchaseProps.new()\n    props.request = Types.RequestPurchasePropsByPlatforms.new()\n    props.type = Types.ProductQueryType.IN_APP\n\n    # Android configuration\n    props.request.google = Types.RequestPurchaseAndroidProps.new()\n    var skus: Array[String] = [product_id]\n    props.request.google.skus = skus\n\n    # iOS configuration\n    props.request.apple = Types.RequestPurchaseIOSProps.new()\n    props.request.apple.sku = product_id\n\n    # Returns typed purchase object or null\n    var purchase = iap.request_purchase(props)\n\n    if purchase:\n        print("Purchase initiated for: ", purchase.product_id)\n    # Purchase result comes via purchase_updated signal\n\nfunc buy_subscription(subscription_id: String, offer_token: String = ""):\n    var props = Types.RequestPurchaseProps.new()\n    props.request = Types.RequestPurchasePropsByPlatforms.new()\n    props.type = Types.ProductQueryType.SUBS\n\n    # Android configuration\n    props.request.google = Types.RequestPurchaseAndroidProps.new()\n    var skus: Array[String] = [subscription_id]\n    props.request.google.skus = skus\n\n    # Android: Add offer token if available\n    if OS.get_name() == "Android" and offer_token != "":\n        var offers: Array[Types.SubscriptionOfferAndroid] = []\n        var offer = Types.SubscriptionOfferAndroid.new()\n        offer.sku = subscription_id\n        offer.offer_token = offer_token\n        offers.append(offer)\n        props.request.google.subscription_offers = offers\n\n    # iOS configuration\n    props.request.apple = Types.RequestPurchaseIOSProps.new()\n    props.request.apple.sku = subscription_id\n\n    iap.request_purchase(props)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"platform-differences",children:"Platform Differences"}),"\n",(0,t.jsx)(n.h3,{id:"ios",children:"iOS"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Single SKU per purchase"}),"\n",(0,t.jsxs)(n.li,{children:["Uses typed ",(0,t.jsx)(n.code,{children:"RequestPurchaseIOSProps"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func buy_ios(product_id: String):\n    var props = Types.RequestPurchaseProps.new()\n    props.request = Types.RequestPurchasePropsByPlatforms.new()\n    props.type = Types.ProductQueryType.IN_APP\n\n    props.request.apple = Types.RequestPurchaseIOSProps.new()\n    props.request.apple.sku = product_id\n    props.request.apple.quantity = 1  # Optional\n    props.request.apple.app_account_token = "user-123"  # Optional\n\n    iap.request_purchase(props)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"android",children:"Android"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Supports multiple SKUs"}),"\n",(0,t.jsx)(n.li,{children:"Subscriptions require offer token"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func buy_android(product_id: String):\n    var props = Types.RequestPurchaseProps.new()\n    props.request = Types.RequestPurchasePropsByPlatforms.new()\n    props.type = Types.ProductQueryType.IN_APP\n\n    props.request.google = Types.RequestPurchaseAndroidProps.new()\n    var skus: Array[String] = [product_id]\n    props.request.google.skus = skus\n    props.request.google.obfuscated_account_id = "user-123"  # Optional\n    props.request.google.obfuscated_profile_id = "profile-456"  # Optional\n\n    iap.request_purchase(props)\n\nfunc buy_android_subscription(subscription_id: String, subscription):\n    # Get offer token from subscription details\n    var offer_details = []\n    if subscription is Object:\n        offer_details = subscription.subscription_offer_details\n    else:\n        offer_details = subscription.get("subscriptionOfferDetailsAndroid", [])\n\n    if offer_details.size() == 0:\n        print("No subscription offers available")\n        return\n\n    var offer_token = offer_details[0].get("offerToken", "")\n\n    var props = Types.RequestPurchaseProps.new()\n    props.request = Types.RequestPurchasePropsByPlatforms.new()\n    props.type = Types.ProductQueryType.SUBS\n\n    props.request.google = Types.RequestPurchaseAndroidProps.new()\n    var skus: Array[String] = [subscription_id]\n    props.request.google.skus = skus\n\n    # Required for Android subscriptions\n    var offers: Array[Types.SubscriptionOfferAndroid] = []\n    var offer = Types.SubscriptionOfferAndroid.new()\n    offer.sku = subscription_id\n    offer.offer_token = offer_token\n    offers.append(offer)\n    props.request.google.subscription_offers = offers\n\n    iap.request_purchase(props)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"product-types",children:"Product Types"}),"\n",(0,t.jsx)(n.h3,{id:"consumable-products",children:"Consumable Products"}),"\n",(0,t.jsx)(n.p,{children:"Consumable products can be purchased multiple times (e.g., coins, gems):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func buy_consumable(product_id: String):\n    var props = Types.RequestPurchaseProps.new()\n    props.request = Types.RequestPurchasePropsByPlatforms.new()\n    props.type = Types.ProductQueryType.IN_APP\n\n    props.request.google = Types.RequestPurchaseAndroidProps.new()\n    var skus: Array[String] = [product_id]\n    props.request.google.skus = skus\n\n    props.request.apple = Types.RequestPurchaseIOSProps.new()\n    props.request.apple.sku = product_id\n\n    iap.request_purchase(props)\n\nfunc _on_purchase_updated(purchase: Dictionary):\n    var state = purchase.get("purchaseState", "")\n    if state == "purchased" or state == "Purchased":\n        # Grant consumable content\n        add_coins(get_coin_amount(purchase.get("productId", "")))\n\n        # Finish as consumable (allows repurchase)\n        var result = iap.finish_transaction_dict(purchase, true)\n        if result.success:\n            print("Consumable purchase finished")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"non-consumable-products",children:"Non-Consumable Products"}),"\n",(0,t.jsx)(n.p,{children:"Non-consumable products are purchased once (e.g., premium features):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func buy_non_consumable(product_id: String):\n    var props = Types.RequestPurchaseProps.new()\n    props.request = Types.RequestPurchasePropsByPlatforms.new()\n    props.type = Types.ProductQueryType.IN_APP\n\n    props.request.google = Types.RequestPurchaseAndroidProps.new()\n    var skus: Array[String] = [product_id]\n    props.request.google.skus = skus\n\n    props.request.apple = Types.RequestPurchaseIOSProps.new()\n    props.request.apple.sku = product_id\n\n    iap.request_purchase(props)\n\nfunc _on_purchase_updated(purchase: Dictionary):\n    var state = purchase.get("purchaseState", "")\n    if state == "purchased" or state == "Purchased":\n        # Grant permanent content\n        unlock_feature(purchase.get("productId", ""))\n\n        # Finish as non-consumable\n        var result = iap.finish_transaction_dict(purchase, false)\n        if result.success:\n            print("Non-consumable purchase finished")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"subscriptions",children:"Subscriptions"}),"\n",(0,t.jsx)(n.p,{children:"Subscriptions require special handling, especially on Android:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func buy_subscription(subscription_id: String):\n    var props = Types.RequestPurchaseProps.new()\n    props.request = Types.RequestPurchasePropsByPlatforms.new()\n    props.type = Types.ProductQueryType.SUBS\n\n    # iOS configuration\n    props.request.apple = Types.RequestPurchaseIOSProps.new()\n    props.request.apple.sku = subscription_id\n\n    # Android configuration\n    props.request.google = Types.RequestPurchaseAndroidProps.new()\n    var skus: Array[String] = [subscription_id]\n    props.request.google.skus = skus\n\n    if OS.get_name() == "Android":\n        # Find the subscription details\n        var subscription = find_subscription(subscription_id)\n        if not subscription:\n            print("Subscription not found")\n            return\n\n        var offer_details = []\n        if subscription is Object:\n            offer_details = subscription.subscription_offer_details\n        else:\n            offer_details = subscription.get("subscriptionOfferDetailsAndroid", [])\n\n        if offer_details.size() == 0:\n            print("No subscription offers available")\n            return\n\n        var offers: Array[Types.SubscriptionOfferAndroid] = []\n        var offer = Types.SubscriptionOfferAndroid.new()\n        offer.sku = subscription_id\n        offer.offer_token = offer_details[0].get("offerToken", "")\n        offers.append(offer)\n        props.request.google.subscription_offers = offers\n\n    iap.request_purchase(props)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"getting-product-information",children:"Getting Product Information"}),"\n",(0,t.jsx)(n.h3,{id:"display-products",children:"Display Products"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func display_products():\n    for product in products:\n        # Access typed properties\n        var title = product.title if product is Object else product.get("title", "")\n        var price = product.display_price if product is Object else product.get("displayPrice", "")\n        var description = product.description if product is Object else product.get("description", "")\n\n        print("Title: ", title)\n        print("Price: ", price)\n        print("Description: ", description)\n        print("---")\n\nfunc get_product_price(product_id: String) -> String:\n    for product in products:\n        var id = product.id if product is Object else product.get("id", "")\n        if id == product_id:\n            return product.display_price if product is Object else product.get("displayPrice", "$0.99")\n    return "$0.99"  # Default price\n'})}),"\n",(0,t.jsx)(n.h2,{id:"purchase-restoration",children:"Purchase Restoration"}),"\n",(0,t.jsx)(n.p,{children:"Implement purchase restoration for non-consumable products and subscriptions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func restore_purchases():\n    # Returns Array of typed purchase objects\n    var purchases = iap.get_available_purchases()\n\n    if purchases.size() == 0:\n        show_message("No purchases to restore")\n        return\n\n    var restored_count = 0\n\n    for purchase in purchases:\n        var product_id = purchase.product_id if purchase is Object else purchase.get("productId", "")\n\n        # Validate on server\n        var is_valid = await validate_on_server_typed(purchase)\n\n        if is_valid:\n            # Grant the content\n            grant_purchase(product_id)\n            restored_count += 1\n\n    if restored_count > 0:\n        show_message("Restored %d purchases" % restored_count)\n    else:\n        show_message("No valid purchases found")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"purchase-verification",children:"Purchase Verification"}),"\n",(0,t.jsx)(n.admonition,{title:"Production Requirement",type:"warning",children:(0,t.jsx)(n.p,{children:"Always validate purchases on a secure server for production apps. Client-side verification can be tampered with."})}),"\n",(0,t.jsx)(n.h3,{id:"server-side-verification",children:"Server-Side Verification"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func validate_on_server(purchase: Dictionary) -> bool:\n    var http_request = HTTPRequest.new()\n    add_child(http_request)\n\n    var body = JSON.stringify({\n        "productId": purchase.get("productId", ""),\n        "purchaseToken": purchase.get("purchaseToken", ""),\n        "platform": OS.get_name().to_lower()\n    })\n\n    var headers = ["Content-Type: application/json"]\n    var error = http_request.request(\n        "https://your-server.com/validate",\n        headers,\n        HTTPClient.METHOD_POST,\n        body\n    )\n\n    if error != OK:\n        http_request.queue_free()\n        return false\n\n    var result = await http_request.request_completed\n    http_request.queue_free()\n\n    var response_code = result[1]\n    var response_body = result[3].get_string_from_utf8()\n\n    if response_code == 200:\n        var data = JSON.parse_string(response_body)\n        return data.get("valid", false)\n\n    return false\n'})}),"\n",(0,t.jsx)(n.h3,{id:"using-native-verification",children:"Using Native Verification"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func verify_purchase_native(purchase: Dictionary) -> bool:\n    var props = Types.VerifyPurchaseProps.new()\n\n    if OS.get_name() == "iOS":\n        props.apple = Types.VerifyPurchasePropsIOS.new()\n        props.apple.sku = purchase.get("productId", "")\n    elif OS.get_name() == "Android":\n        props.google = Types.VerifyPurchasePropsAndroid.new()\n        props.google.sku = purchase.get("productId", "")\n        props.google.package_name = ProjectSettings.get_setting("application/config/package_name")\n        props.google.purchase_token = purchase.get("purchaseToken", "")\n        props.google.access_token = await get_google_access_token()\n        props.google.is_sub = purchase.get("type", "") == "subs"\n\n    var result = iap.verify_purchase(props)\n    return result != null and result.is_valid\n'})}),"\n",(0,t.jsx)(n.h2,{id:"handling-pending-purchases",children:"Handling Pending Purchases"}),"\n",(0,t.jsx)(n.p,{children:"Some purchases may be in a pending state (e.g., awaiting parental approval):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func _on_purchase_updated(purchase: Dictionary):\n    var state = purchase.get("purchaseState", "")\n\n    if state == "pending" or state == "Pending":\n        # Inform user that purchase is pending\n        show_pending_ui(purchase.get("productId", ""))\n\n        # Store pending purchase for later checking\n        save_pending_purchase(purchase)\n        return\n\n    if state == "purchased" or state == "Purchased":\n        # Check if this was a previously pending purchase\n        clear_pending_purchase(purchase.get("productId", ""))\n\n        # Process normally\n        await process_purchase(purchase)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"subscription-status",children:"Subscription Status"}),"\n",(0,t.jsx)(n.h3,{id:"checking-subscription-status",children:"Checking Subscription Status"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func is_subscription_active(purchase) -> bool:\n    var current_time = Time.get_unix_time_from_system() * 1000  # ms\n\n    if OS.get_name() == "iOS":\n        var expiration = 0\n        if purchase is Object:\n            expiration = purchase.expiration_date if "expiration_date" in purchase else 0\n        else:\n            expiration = purchase.get("expirationDateIOS", 0)\n\n        if expiration > 0:\n            return expiration > current_time\n\n        # For Sandbox, consider recent purchases as active\n        var environment = ""\n        var transaction_date = 0\n        if purchase is Object:\n            environment = purchase.environment if "environment" in purchase else ""\n            transaction_date = purchase.transaction_date if "transaction_date" in purchase else 0\n        else:\n            environment = purchase.get("environmentIOS", "")\n            transaction_date = purchase.get("transactionDate", 0)\n\n        if environment == "Sandbox":\n            var day_in_ms = 24 * 60 * 60 * 1000\n            return (current_time - transaction_date) < day_in_ms\n\n    elif OS.get_name() == "Android":\n        # Check auto-renewal status\n        var auto_renewing = null\n        if purchase is Object:\n            auto_renewing = purchase.auto_renewing if "auto_renewing" in purchase else null\n        else:\n            auto_renewing = purchase.get("autoRenewingAndroid", null)\n\n        if auto_renewing != null:\n            return auto_renewing\n\n        # Check purchase state\n        var purchase_state = ""\n        if purchase is Object:\n            purchase_state = purchase.purchase_state if "purchase_state" in purchase else ""\n        else:\n            purchase_state = purchase.get("purchaseState", "")\n\n        if purchase_state == "purchased" or purchase_state == "Purchased":\n            return true\n\n    return false\n'})}),"\n",(0,t.jsx)(n.h3,{id:"managing-subscriptions",children:"Managing Subscriptions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func open_subscription_management():\n    var options = Types.DeepLinkOptions.new()\n\n    if OS.get_name() == "Android":\n        options.package_name_android = ProjectSettings.get_setting(\n            "application/config/package_name"\n        )\n        options.sku_android = "premium_monthly"  # Optional\n\n    iap.deep_link_to_subscriptions(options)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"handling-unfinished-transactions",children:"Handling Unfinished Transactions"}),"\n",(0,t.jsx)(n.p,{children:"Check for unfinished transactions on app startup:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'func _ready():\n    _setup_signals()\n    _initialize()\n\nfunc _initialize():\n    if iap.init_connection():\n        # Check for pending purchases first\n        _check_pending_purchases()\n        # Then load products\n        _load_products()\n\nfunc _check_pending_purchases():\n    var purchases = iap.get_available_purchases()\n\n    for purchase in purchases:\n        var product_id = purchase.product_id if purchase is Object else purchase.get("productId", "")\n\n        # Check if already processed\n        if await is_already_processed(purchase):\n            # Finish the transaction\n            var is_consumable = is_consumable_product(product_id)\n            if purchase is Object:\n                var input = Types.PurchaseInput.new()\n                input.product_id = product_id\n                input.purchase_token = purchase.purchase_token if "purchase_token" in purchase else ""\n                iap.finish_transaction(input, is_consumable)\n            else:\n                iap.finish_transaction_dict(purchase, is_consumable)\n        else:\n            # Process the purchase\n            await process_purchase(purchase)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-gdscript",children:'extends Node\n\nconst Types = preload("res://addons/godot-iap/types.gd")\n\n@onready var iap = $GodotIapWrapper\n\nvar products: Array = []\nvar subscriptions: Array = []\nvar is_connected: bool = false\n\n# Product IDs\nconst COINS_100 = "coins_100"\nconst COINS_500 = "coins_500"\nconst REMOVE_ADS = "remove_ads"\nconst PREMIUM_MONTHLY = "premium_monthly"\n\nfunc _ready():\n    _setup_signals()\n    _initialize()\n\nfunc _setup_signals():\n    iap.purchase_updated.connect(_on_purchase_updated)\n    iap.purchase_error.connect(_on_purchase_error)\n    iap.products_fetched.connect(_on_products_fetched)\n    iap.connected.connect(_on_connected)\n\nfunc _initialize():\n    is_connected = iap.init_connection()\n    if is_connected:\n        _check_pending_purchases()\n        _load_products()\n\nfunc _on_connected():\n    is_connected = true\n\nfunc _check_pending_purchases():\n    var purchases = iap.get_available_purchases()\n    for purchase in purchases:\n        await _process_purchase_typed(purchase)\n\nfunc _load_products():\n    var request = Types.ProductRequest.new()\n    var skus: Array[String] = [COINS_100, COINS_500, REMOVE_ADS, PREMIUM_MONTHLY]\n    request.skus = skus\n    request.type = Types.ProductQueryType.ALL\n\n    products = iap.fetch_products(request)\n    _update_store_ui()\n\nfunc _on_products_fetched(result: Dictionary):\n    # Handle async products fetch (iOS)\n    if result.has("products"):\n        for product_dict in result["products"]:\n            print("Fetched: ", product_dict.get("id", ""))\n    _update_store_ui()\n\nfunc _on_purchase_updated(purchase: Dictionary):\n    await _process_purchase(purchase)\n\nfunc _process_purchase(purchase: Dictionary):\n    var state = purchase.get("purchaseState", "")\n\n    if state == "pending" or state == "Pending":\n        _show_pending_message(purchase.get("productId", ""))\n        return\n\n    if state == "purchased" or state == "Purchased":\n        # Verify on server\n        var is_valid = await _validate_on_server(purchase)\n\n        if is_valid:\n            # Grant content\n            _grant_purchase(purchase.get("productId", ""))\n\n            # Finish transaction\n            var is_consumable = purchase.get("productId", "") in [COINS_100, COINS_500]\n            var result = iap.finish_transaction_dict(purchase, is_consumable)\n            if result.success:\n                print("Transaction finished")\n        else:\n            print("Purchase validation failed")\n\nfunc _process_purchase_typed(purchase) -> void:\n    var product_id = purchase.product_id if purchase is Object else purchase.get("productId", "")\n    var state = ""\n    if purchase is Object:\n        state = purchase.purchase_state if "purchase_state" in purchase else ""\n    else:\n        state = purchase.get("purchaseState", "")\n\n    if state == "purchased" or state == "Purchased":\n        _grant_purchase(product_id)\n\nfunc _on_purchase_error(error: Dictionary):\n    var code = error.get("code", "")\n    match code:\n        "USER_CANCELED":\n            pass  # Silent\n        "ITEM_ALREADY_OWNED":\n            _restore_purchases()\n        _:\n            _show_error(error.get("message", "Purchase failed"))\n\n# Public API\nfunc buy(product_id: String):\n    if not is_connected:\n        _show_error("Store not connected")\n        return\n\n    var props = Types.RequestPurchaseProps.new()\n    props.request = Types.RequestPurchasePropsByPlatforms.new()\n    props.type = Types.ProductQueryType.IN_APP\n\n    props.request.google = Types.RequestPurchaseAndroidProps.new()\n    var skus: Array[String] = [product_id]\n    props.request.google.skus = skus\n\n    props.request.apple = Types.RequestPurchaseIOSProps.new()\n    props.request.apple.sku = product_id\n\n    iap.request_purchase(props)\n\nfunc buy_subscription(subscription_id: String):\n    if not is_connected:\n        _show_error("Store not connected")\n        return\n\n    var props = Types.RequestPurchaseProps.new()\n    props.request = Types.RequestPurchasePropsByPlatforms.new()\n    props.type = Types.ProductQueryType.SUBS\n\n    props.request.google = Types.RequestPurchaseAndroidProps.new()\n    var skus: Array[String] = [subscription_id]\n    props.request.google.skus = skus\n\n    props.request.apple = Types.RequestPurchaseIOSProps.new()\n    props.request.apple.sku = subscription_id\n\n    if OS.get_name() == "Android":\n        var sub = _find_subscription(subscription_id)\n        if sub:\n            var offers = sub.subscription_offer_details if sub is Object else sub.get("subscriptionOfferDetailsAndroid", [])\n            if offers.size() > 0:\n                var sub_offers: Array[Types.SubscriptionOfferAndroid] = []\n                var offer = Types.SubscriptionOfferAndroid.new()\n                offer.sku = subscription_id\n                offer.offer_token = offers[0].get("offerToken", offers[0].offerToken if offers[0] is Object else "")\n                sub_offers.append(offer)\n                props.request.google.subscription_offers = sub_offers\n\n    iap.request_purchase(props)\n\nfunc restore():\n    _restore_purchases()\n\n# Helper functions\nfunc _find_subscription(subscription_id: String):\n    for sub in subscriptions:\n        var id = sub.id if sub is Object else sub.get("id", "")\n        if id == subscription_id:\n            return sub\n    return null\n\nfunc _validate_on_server(purchase: Dictionary) -> bool:\n    # Implement server validation\n    return true\n\nfunc _grant_purchase(product_id: String):\n    match product_id:\n        COINS_100:\n            GameState.add_coins(100)\n        COINS_500:\n            GameState.add_coins(500)\n        REMOVE_ADS:\n            GameState.set_ads_removed(true)\n        PREMIUM_MONTHLY:\n            GameState.set_premium(true)\n\nfunc _restore_purchases():\n    var purchases = iap.get_available_purchases()\n    for purchase in purchases:\n        await _process_purchase_typed(purchase)\n\nfunc _update_store_ui():\n    # Update your store UI\n    pass\n\nfunc _show_pending_message(product_id: String):\n    # Show pending UI\n    pass\n\nfunc _show_error(message: String):\n    # Show error dialog\n    pass\n'})}),"\n",(0,t.jsx)(n.h2,{id:"testing-purchases",children:"Testing Purchases"}),"\n",(0,t.jsx)(n.h3,{id:"ios-testing",children:"iOS Testing"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Create sandbox accounts in App Store Connect"}),"\n",(0,t.jsx)(n.li,{children:"Sign out of App Store on device"}),"\n",(0,t.jsx)(n.li,{children:"Sign in with sandbox account when prompted during purchase"}),"\n",(0,t.jsx)(n.li,{children:"Test with TestFlight builds"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"android-testing",children:"Android Testing"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Create test accounts in Google Play Console"}),"\n",(0,t.jsx)(n.li,{children:"Upload signed APK to internal testing track"}),"\n",(0,t.jsx)(n.li,{children:"Add test accounts to the testing track"}),"\n",(0,t.jsx)(n.li,{children:"Test with signed builds (not debug builds)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./lifecycle",children:"Lifecycle Guide"})," for connection management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./subscription-offers",children:"Subscription Offers"})," for promotional pricing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./error-handling",children:"Error Handling Guide"})," for debugging"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../api/",children:"API Reference"})," for detailed method documentation"]}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},7856(e,n,s){s.d(n,{I:()=>t,V:()=>r});const r="https://iapkit.com",t="https://www.hyo.dev/api/ad-banner/cmju2uzzm0000yr9h3dhpflgy"},8453(e,n,s){s.d(n,{R:()=>a,x:()=>o});var r=s(6540);const t={},i=r.createContext(t);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);