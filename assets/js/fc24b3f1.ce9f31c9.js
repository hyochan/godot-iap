"use strict";(globalThis.webpackChunkgodot_iap_docs=globalThis.webpackChunkgodot_iap_docs||[]).push([[610],{5159(e,n,r){r.d(n,{A:()=>c});r(6540);var i=r(6025),s=r(7856),t=r(4848);function c({title:e}){const n=(0,i.Ay)("/img/iapkit-banner.gif"),r=()=>{fetch(s.I,{method:"POST"}).catch(()=>{})};return(0,t.jsxs)("div",{style:{flex:1,marginTop:24,marginBottom:24},children:[(0,t.jsx)("a",{href:s.V,target:"_blank",rel:"noopener noreferrer",onClick:r,children:(0,t.jsx)("img",{src:n,alt:"IAPKit - In-App Purchase Solution",style:{display:"block",margin:"0 auto",objectFit:"contain"}})}),e?(0,t.jsx)("a",{href:s.V,target:"_blank",rel:"noopener noreferrer",onClick:r,style:{display:"block",fontSize:"0.875rem",color:"#666",textAlign:"center",marginTop:"8px",textDecoration:"none"},children:e}):null]})}},7856(e,n,r){r.d(n,{I:()=>s,V:()=>i});const i="https://iapkit.com",s="https://www.hyo.dev/api/ad-banner/cmju2uzzm0000yr9h3dhpflgy"},8394(e,n,r){r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"api/methods/listeners","title":"Signals (Listeners)","description":"GodotIap provides signals to handle purchase updates and errors. These signals are essential for handling the asynchronous nature of in-app purchases.","source":"@site/docs/api/methods/listeners.md","sourceDirName":"api/methods","slug":"/api/methods/listeners","permalink":"/godot-iap/api/methods/listeners","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/godot-iap/tree/main/docs/docs/api/methods/listeners.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Signals (Listeners)","sidebar_label":"Signals","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Unified APIs","permalink":"/godot-iap/api/methods/unified-apis"},"next":{"title":"iOS-Specific Methods","permalink":"/godot-iap/api/methods/ios-specific"}}');var s=r(4848),t=r(8453),c=r(5159);const o={title:"Signals (Listeners)",sidebar_label:"Signals",sidebar_position:5},a="Signals (Listeners)",d={},l=[{value:"purchase_updated",id:"purchase_updated",level:2},{value:"purchase_error",id:"purchase_error",level:2},{value:"products_fetched",id:"products_fetched",level:2},{value:"subscriptions_fetched",id:"subscriptions_fetched",level:2},{value:"iOS-Specific Signals",id:"ios-specific-signals",level:2},{value:"promoted_product_ios",id:"promoted_product_ios",level:3},{value:"subscription_status_changed_ios",id:"subscription_status_changed_ios",level:3},{value:"Android-Specific Signals",id:"android-specific-signals",level:2},{value:"user_choice_billing_android",id:"user_choice_billing_android",level:3},{value:"developer_provided_billing_android",id:"developer_provided_billing_android",level:3},{value:"Setting Up All Signals",id:"setting-up-all-signals",level:2},{value:"Signal Lifecycle Notes",id:"signal-lifecycle-notes",level:2},{value:"1. Set up early",id:"1-set-up-early",level:3},{value:"2. Clean up properly",id:"2-clean-up-properly",level:3},{value:"3. Handle app states",id:"3-handle-app-states",level:3},{value:"4. Purchase States",id:"4-purchase-states",level:3}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"signals-listeners",children:"Signals (Listeners)"})}),"\n",(0,s.jsx)(c.A,{}),"\n",(0,s.jsx)(n.p,{children:"GodotIap provides signals to handle purchase updates and errors. These signals are essential for handling the asynchronous nature of in-app purchases."}),"\n",(0,s.jsx)(n.h2,{id:"purchase_updated",children:"purchase_updated"}),"\n",(0,s.jsx)(n.p,{children:"Emitted when a purchase is successfully completed or updated."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'func _ready():\n    if Engine.has_singleton("GodotIap"):\n        var iap = Engine.get_singleton("GodotIap")\n        iap.purchase_updated.connect(_on_purchase_updated)\n\nfunc _on_purchase_updated(purchase: Dictionary):\n    print("Purchase received:", purchase)\n\n    var state = purchase.get("purchaseState", "")\n    var product_id = purchase.productId\n\n    match state:\n        "purchased":\n            # Validate receipt on your server\n            var is_valid = await validate_receipt_on_server(purchase)\n\n            if is_valid:\n                # Grant purchase to user\n                grant_purchase_to_user(purchase)\n\n                # Finish the transaction\n                finish_purchase(purchase)\n\n                print("Purchase completed successfully")\n            else:\n                print("Purchase verification failed")\n\n        "pending":\n            print("Purchase pending approval")\n\n        _:\n            print("Unknown purchase state: ", state)\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signal Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"purchase"})," (Dictionary): The purchase object containing:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"productId"})," (String): Product identifier"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"transactionId"})," (String): Transaction identifier"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"purchaseToken"})," (String): Token for verification"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"purchaseState"})," (String): ",(0,s.jsx)(n.code,{children:'"purchased"'}),", ",(0,s.jsx)(n.code,{children:'"pending"'}),", or ",(0,s.jsx)(n.code,{children:'"unspecified"'})]}),"\n",(0,s.jsxs)(n.li,{children:["Platform-specific fields (see ",(0,s.jsx)(n.a,{href:"./unified-apis#purchase-interface",children:"Purchase Interface"}),")"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"purchase_error",children:"purchase_error"}),"\n",(0,s.jsx)(n.p,{children:"Emitted when a purchase error occurs."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'func _ready():\n    if Engine.has_singleton("GodotIap"):\n        var iap = Engine.get_singleton("GodotIap")\n        iap.purchase_error.connect(_on_purchase_error)\n\nfunc _on_purchase_error(error: Dictionary):\n    print("Purchase error:", error)\n\n    var code = error.get("code", "")\n    var message = error.get("message", "")\n\n    match code:\n        "USER_CANCELED":\n            # User cancelled the purchase - don\'t show error\n            print("Purchase cancelled by user")\n\n        "NETWORK_ERROR":\n            show_error_message("Network error. Please check your connection.")\n\n        "ITEM_UNAVAILABLE":\n            show_error_message("This product is currently unavailable.")\n\n        "ITEM_ALREADY_OWNED":\n            # User already owns this product - restore it\n            show_error_message("You already own this product.")\n            restore_purchases()\n\n        "PAYMENT_INVALID":\n            show_error_message("Payment was invalid. Please try again.")\n\n        "PAYMENT_NOT_ALLOWED":\n            show_error_message("Payments are not allowed on this device.")\n\n        _:\n            show_error_message("Purchase failed: " + message)\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signal Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"error"})," (Dictionary): The error object containing:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"code"})," (String): Error code"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"message"})," (String): Human-readable error message"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"domain"})," (String): Error domain (iOS only)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Common Error Codes:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Code"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"USER_CANCELED"})}),(0,s.jsx)(n.td,{children:"User cancelled the purchase"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"NETWORK_ERROR"})}),(0,s.jsx)(n.td,{children:"Network connection error"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ITEM_UNAVAILABLE"})}),(0,s.jsx)(n.td,{children:"Product not available"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ITEM_ALREADY_OWNED"})}),(0,s.jsx)(n.td,{children:"User already owns this non-consumable"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ITEM_NOT_OWNED"})}),(0,s.jsx)(n.td,{children:"Item not owned (for consume/acknowledge)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PAYMENT_INVALID"})}),(0,s.jsx)(n.td,{children:"Payment information is invalid"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"PAYMENT_NOT_ALLOWED"})}),(0,s.jsx)(n.td,{children:"Payments disabled on device"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"BILLING_UNAVAILABLE"})}),(0,s.jsx)(n.td,{children:"Billing service unavailable"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"products_fetched",children:"products_fetched"}),"\n",(0,s.jsx)(n.p,{children:"Emitted when products are successfully fetched."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'var products: Array = []\n\nfunc _ready():\n    if Engine.has_singleton("GodotIap"):\n        var iap = Engine.get_singleton("GodotIap")\n        iap.products_fetched.connect(_on_products_fetched)\n\n        # Fetch products\n        var product_ids = ["coins_100", "coins_500"]\n        iap.fetch_products(JSON.stringify(product_ids), "inapp")\n\nfunc _on_products_fetched(fetched_products: Array):\n    products = fetched_products\n\n    for product in products:\n        print("Product: ", product.productId)\n        print("Title: ", product.title)\n        print("Price: ", product.localizedPrice)\n        print("---")\n\n    update_store_ui()\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signal Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"products"})," (Array): Array of product dictionaries"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"subscriptions_fetched",children:"subscriptions_fetched"}),"\n",(0,s.jsx)(n.p,{children:"Emitted when subscriptions are successfully fetched."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'var subscriptions: Array = []\n\nfunc _ready():\n    if Engine.has_singleton("GodotIap"):\n        var iap = Engine.get_singleton("GodotIap")\n        iap.subscriptions_fetched.connect(_on_subscriptions_fetched)\n\n        # Fetch subscriptions\n        var sub_ids = ["premium_monthly", "premium_yearly"]\n        iap.fetch_subscriptions(JSON.stringify(sub_ids))\n\nfunc _on_subscriptions_fetched(fetched_subs: Array):\n    subscriptions = fetched_subs\n\n    for sub in subscriptions:\n        print("Subscription: ", sub.productId)\n        print("Price: ", sub.localizedPrice)\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signal Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"subscriptions"})," (Array): Array of subscription dictionaries"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"ios-specific-signals",children:"iOS-Specific Signals"}),"\n",(0,s.jsx)(n.h3,{id:"promoted_product_ios",children:"promoted_product_ios"}),"\n",(0,s.jsx)(n.p,{children:"Emitted when a user initiates a promoted product purchase from the App Store."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'func _ready():\n    if Engine.has_singleton("GodotIap"):\n        var iap = Engine.get_singleton("GodotIap")\n        iap.promoted_product_ios.connect(_on_promoted_product)\n\nfunc _on_promoted_product(product_id: String):\n    print("Promoted product purchase initiated: ", product_id)\n\n    # Show your custom purchase confirmation UI\n    var confirmed = await show_product_confirmation(product_id)\n\n    if confirmed:\n        # Complete the promoted purchase\n        iap.request_purchase_on_promoted_product_ios()\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signal Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"product_id"})," (String): The product ID of the promoted product"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Related Methods:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"get_promoted_product_ios()"}),": Get the promoted product details"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"request_purchase_on_promoted_product_ios()"}),": Complete the promoted product purchase"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"This signal only fires on iOS devices when a user taps on a promoted product in the App Store."})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"subscription_status_changed_ios",children:"subscription_status_changed_ios"}),"\n",(0,s.jsx)(n.p,{children:"Emitted when a subscription status changes (iOS only)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'func _ready():\n    if Engine.has_singleton("GodotIap"):\n        var iap = Engine.get_singleton("GodotIap")\n        iap.subscription_status_changed_ios.connect(_on_subscription_status_changed)\n\nfunc _on_subscription_status_changed(status: Dictionary):\n    print("Subscription status changed")\n    print("Product ID: ", status.productId)\n    print("State: ", status.state)\n\n    match status.state:\n        "subscribed":\n            grant_premium_access()\n        "expired":\n            revoke_premium_access()\n        "inBillingRetryPeriod":\n            show_billing_issue_banner()\n        "inGracePeriod":\n            show_grace_period_banner()\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"android-specific-signals",children:"Android-Specific Signals"}),"\n",(0,s.jsx)(n.h3,{id:"user_choice_billing_android",children:"user_choice_billing_android"}),"\n",(0,s.jsx)(n.p,{children:"Emitted when user chooses alternative billing in the User Choice Billing dialog (Android only)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'func _ready():\n    if Engine.has_singleton("GodotIap"):\n        var iap = Engine.get_singleton("GodotIap")\n        iap.user_choice_billing_android.connect(_on_user_choice_billing)\n\nfunc _on_user_choice_billing(data: Dictionary):\n    print("User selected alternative billing")\n    print("Token: ", data.externalTransactionToken)\n    print("Products: ", data.products)\n\n    # Process payment in your payment system\n    var payment_result = await process_external_payment(data.products)\n\n    if payment_result.success:\n        # Report token to Google Play within 24 hours\n        await report_token_to_google(data.externalTransactionToken)\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signal Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data"})," (Dictionary):","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"externalTransactionToken"})," (String): Token to report to Google"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"products"})," (Array): List of product IDs"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{title:"Important",type:"warning",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"externalTransactionToken"})," must be reported to Google Play backend within 24 hours."]})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"developer_provided_billing_android",children:"developer_provided_billing_android"}),"\n",(0,s.jsx)(n.p,{children:"Emitted when user selects developer billing option in External Payments flow (Android only, Japan)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'func _ready():\n    if Engine.has_singleton("GodotIap"):\n        var iap = Engine.get_singleton("GodotIap")\n        iap.developer_provided_billing_android.connect(_on_developer_billing)\n\nfunc _on_developer_billing(data: Dictionary):\n    print("User selected developer billing")\n    print("Token: ", data.externalTransactionToken)\n\n    # Process payment with your gateway\n    var payment_result = await process_payment_with_gateway(\n        data.externalTransactionToken\n    )\n\n    if payment_result.success:\n        # Report to Google Play within 24 hours\n        await report_external_transaction_to_google(\n            data.externalTransactionToken\n        )\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Signal Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data"})," (Dictionary):","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"externalTransactionToken"})," (String): Token to report to Google"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Google Play Billing Library 8.3.0+"}),"\n",(0,s.jsx)(n.li,{children:"Only available in Japan"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"setting-up-all-signals",children:"Setting Up All Signals"}),"\n",(0,s.jsx)(n.p,{children:"Here's a complete example of setting up all purchase signals:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:'extends Node\n\nvar iap: GodotIap\nvar products: Array = []\nvar subscriptions: Array = []\n\nfunc _ready():\n    if not Engine.has_singleton("GodotIap"):\n        print("GodotIap not available")\n        return\n\n    iap = Engine.get_singleton("GodotIap")\n    _setup_signals()\n    _initialize()\n\nfunc _setup_signals():\n    # Core signals\n    iap.purchase_updated.connect(_on_purchase_updated)\n    iap.purchase_error.connect(_on_purchase_error)\n    iap.products_fetched.connect(_on_products_fetched)\n    iap.subscriptions_fetched.connect(_on_subscriptions_fetched)\n\n    # iOS-specific signals\n    if OS.get_name() == "iOS":\n        iap.promoted_product_ios.connect(_on_promoted_product)\n        iap.subscription_status_changed_ios.connect(_on_subscription_status_changed)\n\n    # Android-specific signals\n    if OS.get_name() == "Android":\n        iap.user_choice_billing_android.connect(_on_user_choice_billing)\n        iap.developer_provided_billing_android.connect(_on_developer_billing)\n\nfunc _initialize():\n    var result = JSON.parse_string(iap.init_connection())\n    if result.get("success", false):\n        _load_products()\n\nfunc _load_products():\n    var product_ids = ["coins_100", "remove_ads"]\n    iap.fetch_products(JSON.stringify(product_ids), "inapp")\n\n    var sub_ids = ["premium_monthly"]\n    iap.fetch_subscriptions(JSON.stringify(sub_ids))\n\n# Core signal handlers\nfunc _on_purchase_updated(purchase: Dictionary):\n    print("Purchase updated: ", purchase.productId)\n    await handle_purchase(purchase)\n\nfunc _on_purchase_error(error: Dictionary):\n    print("Purchase error: ", error.code)\n    handle_error(error)\n\nfunc _on_products_fetched(fetched_products: Array):\n    products = fetched_products\n    update_product_ui()\n\nfunc _on_subscriptions_fetched(fetched_subs: Array):\n    subscriptions = fetched_subs\n    update_subscription_ui()\n\n# iOS signal handlers\nfunc _on_promoted_product(product_id: String):\n    print("Promoted product: ", product_id)\n\nfunc _on_subscription_status_changed(status: Dictionary):\n    print("Subscription status: ", status.state)\n\n# Android signal handlers\nfunc _on_user_choice_billing(data: Dictionary):\n    print("User choice billing")\n\nfunc _on_developer_billing(data: Dictionary):\n    print("Developer billing")\n\n# Helper functions\nfunc handle_purchase(purchase: Dictionary):\n    var verified = await verify_on_server(purchase)\n    if verified:\n        grant_purchase(purchase.productId)\n        finish_transaction(purchase)\n\nfunc handle_error(error: Dictionary):\n    if error.code != "USER_CANCELED":\n        show_error(error.message)\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"signal-lifecycle-notes",children:"Signal Lifecycle Notes"}),"\n",(0,s.jsx)(n.h3,{id:"1-set-up-early",children:"1. Set up early"}),"\n",(0,s.jsx)(n.p,{children:"Set up signals as early as possible in your app lifecycle to catch any pending purchases."}),"\n",(0,s.jsx)(n.h3,{id:"2-clean-up-properly",children:"2. Clean up properly"}),"\n",(0,s.jsx)(n.p,{children:"Signals in Godot are automatically cleaned up when the node is freed, but you can manually disconnect if needed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-gdscript",children:"func _exit_tree():\n    if iap:\n        iap.purchase_updated.disconnect(_on_purchase_updated)\n        iap.purchase_error.disconnect(_on_purchase_error)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-handle-app-states",children:"3. Handle app states"}),"\n",(0,s.jsxs)(n.p,{children:["Purchases can complete when your app is in the background. Always handle the ",(0,s.jsx)(n.code,{children:"purchase_updated"})," signal to process any pending purchases when the app resumes."]}),"\n",(0,s.jsx)(n.h3,{id:"4-purchase-states",children:"4. Purchase States"}),"\n",(0,s.jsx)(n.p,{children:"Purchases can be in different states:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"State"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"purchased"})}),(0,s.jsx)(n.td,{children:"Successfully completed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"pending"})}),(0,s.jsx)(n.td,{children:"Awaiting approval (e.g., parental approval)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"unspecified"})}),(0,s.jsx)(n.td,{children:"Unknown state"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Handle each state appropriately in your purchase signal handler."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453(e,n,r){r.d(n,{R:()=>c,x:()=>o});var i=r(6540);const s={},t=i.createContext(s);function c(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);